Про текстуру на воде.
1) Cubemap неба.
2) EMBM + cubamap
3) Сила волн в зависимости от силы ветра.
4) Несколько текстур складывающихся для получения коэффициентов EMBM

Про движение по скоростям.
1) Процесс, указывающий на скорость в текущий момент. D3DFMT_V16U16 (256,256)

2) Процесс передвижения пикселей
   dst=lerp(dst,tex(x+du,y+dv),alpha)

///////////
Первый вариант
2 текстуры для EMBM
текстура неба (2D)
прозрачность везде одинаковая

//Второй вариант
1 глубина + 1D текстура для неё
2 текстуры для EMBM
текстура неба (2D)

прозрачность зависит от глубины и суммы текстур EMBM
сила бликов - от силы ветра и угла обзора 


/////////////////Про ночь
Вечером тени постепенно исчезают.
Specular постепенно падает до нуля.
Diffuse сначала уменьшается, но с восходом луны опять появляется синеватый.
Ambient растёт в сумерках, ночью уменьшается. 
!!!! Не забыть включать lightmap ночью.

/////////////////Про замерзание воды
  В тех местах другая текстура всё по другому. 
Явно нужно тайликами делать. Зато так как снег статичен, то не будет проблем с пересылкой данных.
2 текстуры. Одна - общий рисунок. 
Другая краевая alpha, и всякие внутренние красивости тайловые.
Край и внутренние тайлы поразному интерпретируют alpha второй текстуры.

  Управлять замерзанием - точки генерации холода.
  Проблемы с замерзанием воды - вода хочет течь, а лед остаётся на своем месте.
  Возможно захотят таяние льда, с отколом льдинок, и движением их по течению.
  
Вода хочет течь, а лед остаётся на своем месте. 
- Это проблемма с апдейтом большого количества данных по AGP.

Граничные тайлы отображаются подругому. Динамическое изменение индекс буфера?
Деление на водные, замерзшие и граничные тайлы.
Тайлы снега изменяются только по границе, это экономит процессорное время.
Тайлы замерзают и тают постепенно.
Нужно придумать инкрементальный процесс замерзания и разбиения воды на тайлы.

Хитрый индекс буффер, в котором можно удалять с любого места, а перед рендерингом дырки 
исчезают за счёт компактификации.

Пока для простоты (и скорости) лёд будет использовать вертекс буфер воды, 
но собственный индекс буфер и рисоваться поверх. 
Потом там где есть лёд, вода не должна будет рисоваться (дуальный инкрементальный индекс буфер).
Это решает почти все проблеммы, кроме граничных тайлов.

Граничные тайлы рисуются два раза. Снизу вода, сверху лёд, это значит что лёд непрозрачен.

Температура пускай будет в виде таблицы 128x128.
Преобразование температуры в тайлы.
При замерзании ориентировать тайлы по градиенту.
Есть несколько стадий замерзания.
 Лёд из мелкой крошки, с водой, не блестит.
 Белый лёд, ориентированный по градиенту. В зависимости от величины градиента получаются разные тайлики. Блестит как снег.
 При таянии мелкие льдинки могут откалываться, плыть по течению, таять либо уходить под лёд.
 При таянии лёд становится гладким и блестит как лёд.
 
Оставшийся нерешённым вопрос - преобразование температуры на границе в тип тайла так, что-бы красиво было.

////////////////////////////////////////////////////////////////////
Как преобразовывать в тип тайла прорисовки.
Пускай есть вода, лёд и граница.
при t>tтаяния - вода,
    t<tзамерзания - лёд.
    tзамерзания<t<tтаяния - граница (всё более тонкий лёд).


///////////////////////////Молнии
Состоят из прямых участков и разветвлений.
Основная проблемма - как состыковать разветвления с прямыми участками в трехмерном пространстве.


//////////////////////////О границе воды
Основной постулат - вода должна быть ровная на границах, она должна плавно наливаться и плавно исчезать.
Для плавности на границе воды должна постепенно меняться как высота, так и прозрачность.
Есть несколько типов ячеек:
   1) Безводные - нет воды в ней и в граничных к ней тайлах.
   2) Водные - есть вода в ячейке.
   3) Граничные - нет воды, но в граничных тайлах вода есть.

   Основная проблемма - с граничными тайлами.
     1) Если вода вокруг глубоко под землей, то высота в нем должна быть равна высоте воды в окружающих его водных тайлах,
         с прозрачностью окружающих водных тайлов. (Высота тоже должна изменяться плавно.)
     2) Если вода вокруг очень мелкая, то высота должна быть немного выше уровня земли, 
         а alpha постепенно переходить в 0.
         
   Определить какой вариант необходимо использовать можно заранее при инициализации/изменении высоты земли.
   Как определить что тайл граничный - при изменении типа с безводного на водный и обратно, 
   в 8 бит окружающих тайлов записывается значение безводный/водный у этого тайла.

   1 бит - есть ли вода
   1 бит - ровная ли местность (на ровной местности вода сохнет/наливается не так, как на неровной)
   
   Проблемма осложняется тем, что могут быть видимы не только граничные тайлы, 
   но и тайлы за пределами границы на одну клетку вокруг. Но не должны.
   
   underground_z в пустых неграничных тайлах должна быть.
      1. На ровной местности - на высоте земли+чуть чуть.
      2. На кривой местности - минимальной высоте земли в окружающих тайлах+чуть чуть.
   
   Если вода мелкая и через тайл от неё глубокая вода, 
   то заполненные тайлы с мелкой водой должны иметь прозрачный цвет.

/////////////////////////О подсвечиваемых плохих объектах
1 - объекты со слишком мелкими треугольниками.
2 - объекты с слишком большим размером текстур по сравнению с видимой площадью
2.5- объекты с некорректным маппингом моделей (размер текселя значительно меньше размера пикселя)
3 - объекты с разным количеством костей (1,2,3,4)
4 - объект со слишком большим количеством node


/////////////////////////О HT, интерполяции, смене цепочки анимации и блендинге.

Высокоуровневые команды разбиваются на команды - 
  проиграть от и до такую цепочку. Причем нет перехода за границу 0..1.

Высокоуровневая команда - проиграть эту цепочку, после окончания проиграть другую цепочку.


////////////////////////О самосветящихся окнах.
Отдельная текстура, которая имплементируется с diffuse. Несовместима с alpha.


///////////////////////О том, как делать части объектов прозрачными.
При экспорте бить объект на несколько подобъектов с общими анимационными цепочками, но разными root node.
Записывать информацию о линковке объектов.

При импорте:
   1 - читать их.
   2 - линковать.
   3 - генерировать прокси объект 
       Но прокси объект по началу можно не генерировать,
       а потом например только управление анимационными группами.

Интерфейс экспортера.
   Говорится какие объекты дополнительные.
   Название их пускай будет по названию родительской ноды (при линковке проще будет).
   
////////////////////////О прозрачности для групп видимости.
Рисовать отдельным проходом просто.
Формализовать понятие прохода.
Разделить понятие прорисовки/установки материала.
Растащить цикл cObject3dx::Draw
Непрозрачные объекты сортировать по текстурам.
Прозрачные объекты с записью в Z буфер рисовать с D3DRS_ALPHAREF=80
Встроить в камеру поддержку вывода разнородных объектов в фиксированом порядке (для тумана, воды и т.д.).

RenderPipeline - 
   Установка материала, вывод примитивов.
   Позволяет не считать несколько раз материал и матрицы, 
   и не считать несколько раз, какие DiP вызывать,
   можно пересчитывать в PreDraw.
   
   Недостатки - нужно много памяти (особенно на матрицы).
   
//////////////////////О отражениях в воде

1 - вместо кубемапа использовать планарную с большим fov.
2 - преобразовывать ее в кубемап U16V16
 ---- не прокатит, разрешение rendertarget неравномерно распределяется.

1 - SetClipPlane + рендеринг тайла.
    Получается много-много маленьких камер в одной текстуре.
    + ужасающая производительность.
    если правильно полигонизировать, может не так уж и плохо получится.
    проблема со стыковкой плоскостей.

	Рендерить отражение относительно плоскости, резать объекты по высоте воды,
	дальше - делать корректировку на сдвиг по высоте в пиксель шейдере (и размеры откорректировать).
	Отражать от средней высоты для видимой воды.
	
	По шагам.
	  Сначала имплементировать отражение от фиксированной плоскости.
	  Потом уже добавлять зависимость от высоты.
	

//////////////////////////О тенях
bias - при слишком  большом  - видна неосвещенная полоска.
      при слишком маленьком - происходит затенение за счет боковых пикселей.
      Выход D3DRS_SLOPESCALEDEPTHBIAS! Но он работает тольео для Geforce.

bias для TSM.
	  Нужен сдвиг примерно на пиксель в зависимости от положения.
	  
Не забыть попробовать обратную сторону объектов.
 !!!!! try set correct bias to CCW


/////////////////////////О отражениях опять.
Вода локально плоская, можно рендерить в этом месте плоско.
В мелких зонах отражения не будет видно (а будет быстротекущая вода типа).


В текстуру можно писать высоту воды, а потом в вертекс шейдере по z резать и заодно 
сдвиг с фиксом в отдельном проходе делать.


Если zводы>zотражения, то искажения не такие страшные чем при zводы<zотражения.


/////Что еще сделать.
1 - посчитать минимальную Z для видимой области. Ok.
2 - правильно высчитать видимость для lightmap.
3 - дописать шейрер для объектов , чтобы по Z отрезал.
4 - разобраться почему тени конфликтуют с отражениями. Ok.
5 - Написать красивый шейдер для воды.

О компиляции шейдеров, и последующем их выборе.
1. Надо разные сборки шейдеров для разных видеокарт.
2. Указывать, какие дефайны выставляются только при загрузке, а какие меняются в реальном времени.

