О батчинге примитивов и сопутствующих оптимизациях.

Известные факты - переключение текстур, шейдеров, VB и IB довольно 
                  дорогая операция.
Спорные факты - смена шейдерных констант - недешёвая операция
                (придётся мерять на разном железе).

Варианты решения
  1) Сортировака по материалам 
     (решает проблеммы с переключением текстур, шейдеров)
     Можно сделать автоматическую пресортировку, используя 
     указатель в материале.
  2) Статический биндинг разных параметров, для уменьшения количества 
     SetVertexShaderConstant.
  3) Запихнуть в один VB несколько претрансформированных объектов 
     (только для статической геометрии, нужно использовать SSE).
  4) Индексный скининг с одной костью - не быстро, по сравнению с вариантом 
     без индексирования.


О памяти. Известно что память сейчас достаточно медленна, 
  особенно при случайном доступе. 
  Решением является уменьшение количества объектов, а так-же их размеров.
  1) cObject3dx является шагом в этом направлении.
  2) Быть может следует создать аналогичный cObject3dx объект,
     но с миниумом возможностей. Убрать возможности
       Изменять цвет. 12*4=48 байт.
       Скин color - 12 байт.
       Привязывать спецэффект. 16 байт.
       sBox6f box - 24 байта.
       GetAttribute - 4 байта
       Всего 104 байта экономим
       232-104=128 ! :)

О процессорных операциях. 
    Вот цифры - если убрать 18 умножений и 9 сложений из главного цикла вывода 
    объектов, скорость увеличивается не 30%.
   
     

//////////////////////О интерполяции костей для скелетной анимации.
vector<cNode3dx> nodes; 
Должно быть несколько штук, и между ними производиться интерполяция.
position и scale - линейно интерполировать
rotation - быстрым lerp c нормализацией

Инерполяция только 2 цепочек. (Хотя нет принципиаольных ограничений и на суммирование нескольких чепочек).
О интерфейсе со стороны пользователя.
   Есть анимационные цепочки.
   Есть группы анимации.
   Есть анимационные фазы.
   Есть прямое управление положением ноды. (Конфликт решается ATTRUNKOBJ_NOUPDATEMATRIX)
   Блендинг интерполяции материалов не предусмотрен (пока).
   
   Прямое управление.
      1. Создать вторую анимационную sequence (Mats для всех нод).
      2. Указать коэффициэнт интерполяции для каждой анимационной группы.

	Косвенное управление из другого потока при интерполяции цепочек.
	Так как планируется такую интерполяцию использовать для плавного переключения анимационных чепочек.
	   1. Это решает гейм дизайнер и ставит галочку возможна ли такая анимация ДО создания модели.
	   2. При переключении цепочек выключаемая цепочка доигрывается постепенно затухая. 
	      Время затухания, скорость и направление проигрывания, а также зацикленная ли это цепочка 
	      передается из логики.
	   3. 

//////////////////////О исчезновении объектов с расстоянием.
 Критерии исчезновения (варианты)
    1. несколько фиксированных расстояний по уровнем LOD.
    2. в зависимости от размеров объекта.
    
 Объекты могут исчезать и появляться.
    1. мгновенно
    2. постепенно изменяя alpha.
    Сделали пока простейший вариант.
    
//////////////////////О культурной многопоточности.
    К сожалению lock нельзя инкапсулировать внутрь низкоуровневых функций,
    потому как тогда он будет вызываться слишком частно, а в некоторых случаях не получится 
    корректного кода без сложных смарт поинтеров.
    Поэтому нормальная ситуация - ресурс залокирован, к нему обратились, разблокировали.
    Более того - это очень хорошо кореллирует с сетевым кодом и повторяемостью.
    
    Поэтому например задание "HT: Нужна возможность обращаться к списку заселектированных юнитов из логического кванта."
    вкорне неверно в своей постановке.
    Правильно действовать надо так:
    1. Либо послать команду аналогичную сетевой (самый правильный вариант).
    2. Либо заблокировать список вначале логического кванта, обратиться к нему, разблокировать.
    
    Со всякими мелкими параметрами - следует держать 2 копии параметров и копировать их в соответствующюю сторону.
    Здесь очень хорошо подходит понятие pipe (трубы где течет в одну сторону). Объект пишется только в одном потоке, 
    а читаться может в двух потоках. Lock на них должен быть общий в момент копирования. 
    
	Ни в коем случае нельзя делать темплейт, который автоматически лочит объект прозрачно для пользователя.
	Слишком велик психологический соблазн им воспользоваться.
	
	Паттерн, всегда проверяющий корректность обращения и выдающий assert если что. (В final отрубается).
	
/////////////////////О круглых селектах, которые внутри не перекрываются друг с другом.
   Сначала есть круг, потом пересечение нескольких.
   Это представляется ввиде нескольких связных дуг, которые потом переводятся в сплайн.
   
   Основная проблемма - как к связному списку дуг добавить быстро еще один круг.
   Точнее так - как в случае сильнопересекающихся кругов избежать асимптотики N^2
   
   Быть может сортировать круги так, чтобы с большей вероятностью убивалась граница?
   
   Например построить бинарное дерево, а потом сливать ближние. И убивать нижний уровень дерева.
   Это позволит уменьшить площадь отрезков. Если на каждом уровне строить дерево для fast-regect,
   то получим наверно N*(log(N)^2).
   
   О надежном методе связывания кругов.
   Функции intersect_segment должна быть объединена в одну функцию.
   
//О статистике, которая нужна в редакторе по графике.
1. Количество текстур в текстурной памяти.
2. Количество текстур под карту в текущий момент.
3. Количество полигонов в кадре.
4. Объем видеопамяти под геометрию.
5. Количество видимых объектов.
6. Количество видимых спецэффектов.
7. Общее количество объектов.
8. Общее количество спецэффектов.

//О линковке одного 3Д объекта к другому.
Вставить в cObject3dx класс ObserverLink для связи с другим.
Нужно отсортировать объекты по зависимости одного объекта от другого.

О доступе к объектам из тумана войны, объектов загораживающих объекты и т.д.


//О более разнообразном выставлении групп анимации.
Имеем дилемму - объект хочется по частям включать и выключать, но просто групп видимости не хватает.
Сбоку стоит вопрос - о динамическом доступе к точнам на поверхности объекта для спецэффекта.
Еще вопрос - о плавном появлении и исчезновении частей объектов и линковке их по материалам в более крупные массивы.

Понятно, что статический батчинг противоречит динамическому переключению. Но и группы видимости так оставлять нельзя.
В объекте суммарно должно быть меньше 65536 полигонов со всеми группами видимости.

Если разбить объект на несколько подгруп и разместить их последовательно в буфере, то ...

Учесть, что нет принципиальной разницы между прилинковываением отдельного объекта и включением группы.
Проблеммы - 
    батчинг
    большое количество невидимых нод
    большое количество текстур


    Если размещать в отдельных вертекс-индекс буферах.
       Нет проблем с созданием-удалением.
       Проблеммы с батчингом.
       Нет проблем с количеством дополнительных нод.
       Но так как таких объектов немного, то все ок.
       
Реализация - 
   есть простой 3Д объект без возможности привязки,
   есть составной 3Д объект с возможностью привязки.
   составной объект состоит из простых, перенумерует хэндлы так, 
   чтобы не пересекались индексы. Можно переключать группы видимости 
   у каждого простого объекта в отдельности.
   
   В экспорте дополнительная менюха - указать какие меши принадлежат к каким подобъектам,
   а в группах видимости уже указывать - видим или нет.
   
   Дополнительная экспортируемая информация - какие меши принадлежат к каким подобъектам,
   и как слинкованны ноды.
   
   --- В составном объекте прописан порядок апдейта нод и порядок прорисовки подобъектов.
   В составном объекте хранятся все ноды и есть интерфейс для переключения групп видимости в простых объектах.
   В простом - матрицы не апдейтятся, а берутся из объекта верхнего уровня.
   
   Есть:
    Ноды.
    Меши объединяются по группам видимости.
    Все хранится в одном вертекс и индекс буфере и по необходимости копируется туда. 
    <- нестатичные данные уникальные для каждого объекта :(
    
   Есть:
    Ноды в составном объекте, которые ссылаются на разные pStatic, и имеют 
    перенумеровочные коэффициэнты для них.
    
   Есть:
    Простые объекты, которые имеют полный функционал, кроме порядка апдейта нод.
    Составной объект - 
       включает в себя порядок апдейта нод и их перенумерацию.
       интерфейс для доступа к групам видимости простых объектов.
    
    В экспортилке - выбор какая из нод и какой из мешей принадлежит к какому объекту.
    В крайнем случае это позволит делать хитроразбитые объекты, хотя магистральный путь 
    - один объект, одно положение.
    Позволит в дальнейшем прилинквывать отдельные объекты, причем линковать сложным способом.
    
	В экспортере - какая нода куда входит. Строится таблица перенумерации.
	
	
	Проблемма при текущей реализации групп видимости - дублирование геометрии.
	Какие проблеммы планируется решить:
	1. Разрушение зданий посредством подмены групп видимости.
	2. Одевание на людей разной одежды.
	  2.1 База данных и динамическая подгрузка разной одежды.
	  2.2 Должна быть обязательно возможность как линковки внешних, так и внутренних объектов.
	  2.3 Должна быть возможность хранения нескольких 3dx в одном файле.
	  2.4 cObject3dx - возможность задания нескольких точек линковки, с последующим 
	      последовательным апдейтом в cObject3dmulti. Несколько разрушает
	      стройность концепции. Подумать можно ли обойтись одной точкой привязки.
	      Особенно в случае разрушения зданий.
	      
    Изменения в интерфейсе - cObject3dmulti включает в себя все возможности cObject3dx + изменение групп видимости.
    К объектам можно обращаться по именам.
    
	
	
	Или так - 
	  1. есть полноценные 3dx объекты с несколькими группами видимости внутри.
	  2. есть возможность линковать несколько 3dx объектов.
	      Главное не забыть их в нужном порядке выводить.
	
	  Все в группе видимости должно быть в одном VB/IB. А переключаться за счет большого количества DIP.
	  В VB/IB должна остаться сортировка по материалам, но модели не должны самопересекаться.
	  
	  
    О внутренних структурах для множеств видимости.
      1 - что делать с lod? 
         Лоды могут быть в любой группе видимости, и отличаются постфиксами lod01,lod02,lod03.
         Если найденно три имени с такими постфиксами, то имена обрезаются, а лоды переключаются.
      2 - появилась принципиальная возможность использовать трэк видимости для видимости мешей.
         

///////////////////////О упрощенном объекте
   ///Тяжелый вариант упрощенного объекта.
   Должен быть один материал.
   Нет анимации.
   Нет привязки спецэффектов.
   Нет групп видимости.
   
   Есть несколько нод для шевеления ветром или осколков. (Предполагается что их мало!!!!! 1-5 нод.)
   Внутри эти объекты сортируются по материалу.
   У них есть только простые материалы.
   Из изменения цвета - только модуляция alpha.

   ///Реализация.
   Объекты кучкуются по группам.
   Как можно более быстрая проверка на видимость.
   В Вертекс/Индекс буферах дублирунтся много раз объекты для уменьшения количества DIP.
   Полупрозрачные объекты хранятся в отдельном списке и выводятся по отдельности.
   
   Объекты создаются из 3dx моделей, но всилу своей упрощенности берут лишь первый объект 
   из определенной группы видимости.
   
   HINT: Можно проходя по списку отсортировать его по видимости для последующей обработки.
   HINT: Можно сделать оператор new для локального размещения объектов.
   
   О LODах для cSimply3dx:
   1) Рассчитываем LOD, cортируем видимые объекты по LOD.
      Причем сортировка такова, что значение LOD считается 1 раз, и не храниться нигде.
      Можно сортировать около DIP. Смотрим LOD и ложим в соответствующий массив, 
      как только он заполняется, выаодим.
      
   2) Заполняем IB/VB тремя LODами из одного cStaticIndex.
      Потом при выводе будут offset при DIP.
      
   3) Количество костей может быть разное для каждого лода, поэтому надо будет таблицы перенумерации.
   
   3) Или так - ноды есть все, которые нужны для 3 lod`ов, и есть индексы на матрицы, в каком лоде что используется.
   
///////////////////////О тенях кружочками и освещении.
    Думаем о возможности делать тени только на земле и только на объектах.
    Все хреново!
    Решение - только 2 RT отдельно для объектов и отдельно для мира.
    Нужно более четкое разделение:
    1. Есть земля и трава/мусор на ней.
         На траву/мусор откидываются тени кружочками и освещение с соответствующей галочкой и тени от облаков.
    2. Есть объекты.
         На объекты откидывается освещение с соответствующей галочкой и тени от облаков.
    
    
//////////////////////О изменении внешнего вида под водой.
    Сделать просто туман поближе да посинее + постэффект, который все синее делает.

    Тут основное - сделать поддержку постэффектов.
    Текстура дополнительная в DEFAULT pool по размеру экрана.
    StretchRect для копирования в неё.

//////////////////////О отражениях в свете клиппинга вторым z буфером.
   Предпологаем что вода почти плоская. 
   В этом случае можно представить воду плоскость + небольшое смещение, которое записанно в текстуре.
   
   Отражаем все от плоскости, режем texkill по высоте воды отраженную картинку.


///////////////////О формате вертексов для земли
	{ 0, 0, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0 }, 
	{ 0, 4, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_COLOR, 0 },
	
А потом будет восстанавливаться x,y,z - short, нормаль из двух байтов.

float3 p;
p.z=sqrt(1-p.x*p.x-p.y*p.y);
Как можно заменить ее на 
p.z=c
p=normalize(p)


sqrt(p.x*p.x+p.y*p.y+p.z*p.z)=1
sqrt(p1.x*p1.x+p1.y*p1.y+c*c)=len

p.x=p1.x/len
p.y=p1.y/len
p.z=c/len

len=c/p.z
p1.x=p.x/len
p1.y=p.y/len

c нужно такую выбрать, чтобы p1.x, p1.y не превысили разрешенных пределов.

///О экономии текстурной памяти.
1. Лоды текстур можно определять по другому алгоритму по сравнению с лодами поверхности.
2. Разделить апдейт текстур и вершин. Более того можно разделить апдейт  (x,y) и (z) у них.
3. 




////////////////////////////Про сцену, и вывод объектов в нужном порядке.
1. Камера должна быть отвязанна от сцены.
2. Должна быть возможность выводить несколько сцен в одной камере.
3. Необходимо указывать порядок вывода сцен.

Камера shadow map.
  Вывод непрозрачных объектов.
  Вывод прозрачных с alpha-test.
  
Камера light map.
  Вывод источников света
  Вывод туч.

Камера reflection.
  Вывод неба.
  Вывод всех объектов.
  
Камера reflection.
  Вывод неба.
  Вывод всех объектов.
  
Камеры для cubemap.
  Вывод неба.

 Аккуратно оформить cCamera::pTestGrid, чтобы значит вычислялся для каждой камеры отдельно, и если нужно.
 GetScene -> GetCurrentDrawScene
 Камеры больше не принадлежат сцене.
 
 Избавиться от FindChildCamera в PreDraw.
 Вызываться TestVisible для каждой камеры. Если объект видим - запихиваться в нужное место в очереди на отрисовку.
 
 
 /////////О траве.
 Пускай трава будет тоже в мультирегионе и генериться на лету.
 Будет несколько видов травы. Все будет побито на квадраты 64x64.
 Трава только alpha-test ом.
 1. Можно не сортировать. 
 2. На большом 
 
 Отдельный вопрос про сжигание травы.
	short3 - pos
    short - type
    
Рисовать     
    
/////////О камере в логике, проверке на видимость и передаче параметров только видимых объектов.
1. Камера должна интерполироваться. Есть frustrumы логические для каждой камеры по одному. 
			Интерполяция - это дело пользователя.
2. Объект видим если его видно в предыдущий или текщий кадр.
3. Есть 3 значения - видимость на предыдущий логический квант, на текущий логическмй квант и 
           видимость в графическом интервале.
           
           
Как достичь этого.
0. Нельзя будет привязывать автоматически спецэффекты к объектам.
1. Фларики нормально работать будут.
2. Анимация материалов - как то глобально желательно сделать и на int ах, чтобы fmod не было много,
   и главное нормально материал нормально крутился при больших числах.
3. Создается front_end объект для логики, вся интерполяция происхродит внутри него, операции 
   update для 
    
 
 //////////////////////Трава
 Есть несколько типов травы.
 Есть маски плотности травы в разных местах.
 Есть инструмент увеличения плотности конкретного типа травы.
 Есть инструмент уменьшения суммарной плотности травы.
 Маски дизерингом переводятся в траву.
 
 Каждый тип травы задается несколькими кадрами травы и несколькими кадрами цветочков.
 Трава - поворачивается к наблюдателю. Цветы не поворачиваются.
 
 Ветер гораздо лучше заметен как изменение освещения.
 
 
 /////////////////Опять о силуэтах
 Нужно (взаимоисключающие варианты)
 1. Объекты не рисовались под землей.
	 Очистить alpha=0
     Пусть сначала рисуется земля.
     Потом no-z спецэффекты (тут не получится порядок поменять).
     
     Потом SilhouetteObject с нужными stencil и alpha=0 масками. (НЕ получится, не будет alpha-test работать в этих объектах)
     Потом объекты которые могут закрывать SilhouetteObject c 255 alpha маской.
 
 
 2. Объекты рисовались силуэтами, когда не видим центр объекта.
 
  
 Силуэты, известные алгоритмы.
   1) Нарисовать объект с zfunc=greatequal, потом нарисовать его с zfunc=less (двупроходный)
   2) Нарисовать объект в stencil при D3DRS_STENCILZFAIL и alpha, объекты без силуэтов не рисовать 
		ни в stencil ни в alpha.
       Потом рисовать спрайты с D3DBLEND_INVDESTALPHA и D3DRS_STENCILFUNC=D3DCMP_EQUAL.
       
      В этих алгоритмах есть проблема. Объекты могут немного проваливаться под землю.
      
   3) Один из вариантов решения - occlusion query, если объект полностью закрыт, то рисовать силуэт.
   4) Землю можно рисовать после силуэтов.
   5) Землю рисовать вначале, но силуэты выводить, только если четное количество раз пересекается с землей.
       (недостаток - только новое железо).
       
   
   
//////////////////Про проблемы с глобальными рендерстейтами.
    Выставляются в одном классе, а другой класс перестает работать, 
    так как не ожидал, что этот рендерстейт может поменяться.
    
    Разбить рендерстейты на группы, и выставлять полностью группу.
    Основная цель - избавиться от мест, где выставляется предыдущее состояние рендерстейтов.
        
Пример -     
union SAMPLER_DATA
{
	struct {
		DWORD addressu:3;
		DWORD addressv:3;
		DWORD addressw:3;
		DWORD minfilter:3;
		DWORD magfilter:3;
		DWORD mipfilter:3;
		DWORD :14;
		
		DWORD bordercolor;
	}
	
	DWORD dword[2];
};

Соответственно нигде не должно быть куча SetSamplerState,
а должно быть одно SetSamplerData(SAMPLER_DATA);

generic - используется только в BeginScene

struct ALPHABLEND_DATA
{
1	D3DRS_ALPHATESTENABLE - frequency
1	D3DRS_ALPHABLENDENABLE - frequency
4	D3DRS_SRCBLEND - frequency
4	D3DRS_DESTBLEND - frequency
3	D3DRS_BLENDOP - frequency
8	D3DRS_ALPHAREF - frequency
4	D3DRS_ALPHAFUNC - rare 
	//Кстати подумать D3DCMP_GREATER или D3DCMP_ALWAYS
	//Наверно D3DCMP_ALWAYS для ALPHABLEND ,   D3DCMP_GREATER для ALPHATEST.!!!!!
	
	///Пожалуй не поддерживать этот флаг.
	D3DRS_BLENDFACTOR - none
}

struct STENCIL_DATA
{
1	D3DRS_STENCILENABLE 
4	D3DRS_STENCILFAIL
4	D3DRS_STENCILZFAIL
4	D3DRS_STENCILPASS
4	D3DRS_STENCILFUNC
8	D3DRS_STENCILREF
8	D3DRS_STENCILMASK
8	D3DRS_STENCILWRITEMASK
}

struct Z_DATA
{
1	D3DRS_ZENABLE - rare
1	D3DRS_ZWRITEENABLE - frequency
4	D3DRS_ZFUNC - frequency
}

struct FOG_DATA
{
32	D3DRS_FOGCOLOR - generic
1	D3DRS_FOGTABLEMODE - generic
32	D3DRS_FOGSTART - generic
32	D3DRS_FOGEND - generic
32	D3DRS_FOGDENSITY - rare
1	D3DRS_FOGVERTEXMODE - generic
}
1	D3DRS_FOGENABLE - frequency

D3DRS_COLORWRITEENABLE - frequency


D3DRS_FILLMODE - generic
D3DRS_SHADEMODE - generic
D3DRS_LASTPIXEL - generic
D3DRS_CULLMODE - generic
D3DRS_DITHERENABLE - generic
D3DRS_ANTIALIASEDLINEENABLE - generic
D3DRS_MULTISAMPLEANTIALIAS - generic
D3DRS_MULTISAMPLEMASK - generic
D3DRS_CLIPPLANEENABLE - generic
D3DRS_SRGBWRITEENABLE - generic
D3DRS_AMBIENT - generic
D3DRS_COLORVERTEX - generic
D3DRS_CLIPPING - generic

D3DRS_DEPTHBIAS - rare
D3DRS_SLOPESCALEDEPTHBIAS - rare

D3DRS_TEXTUREFACTOR - fixed,  rare


D3DRS_LOCALVIEWER - fixed
D3DRS_NORMALIZENORMALS - fixed
D3DRS_DIFFUSEMATERIALSOURCE - fixed
D3DRS_SPECULARMATERIALSOURCE - fixed
D3DRS_AMBIENTMATERIALSOURCE - fixed
D3DRS_EMISSIVEMATERIALSOURCE -fixed

D3DRS_WRAP0-D3DRS_WRAP7 - none
D3DRS_POINTSIZE - none
D3DRS_POINTSIZE_MIN - none
D3DRS_POINTSPRITEENABLE - none
D3DRS_POINTSCALEENABLE - none
D3DRS_POINTSCALE_A -none
D3DRS_POINTSCALE_B - none
D3DRS_POINTSCALE_C - none
D3DRS_SPECULARENABLE - none


D3DRS_PATCHEDGESTYLE - none
D3DRS_DEBUGMONITORTOKEN - none
D3DRS_POINTSIZE_MAX - none
D3DRS_INDEXEDVERTEXBLENDENABLE - none


D3DRS_POSITIONDEGREE - none
D3DRS_NORMALDEGREE - none
D3DRS_SCISSORTESTENABLE - none 


D3DRS_MINTESSELLATIONLEVEL - none
D3DRS_MAXTESSELLATIONLEVEL - none
D3DRS_ADAPTIVETESS_X
D3DRS_ADAPTIVETESS_Y
D3DRS_ADAPTIVETESS_Z
D3DRS_ADAPTIVETESS_W - none
D3DRS_ENABLEADAPTIVETESSELLATION - none

D3DRS_TWOSIDEDSTENCILMODE - none
D3DRS_CCW_STENCILFAIL - none
D3DRS_CCW_STENCILZFAIL - none
D3DRS_CCW_STENCILPASS - none
D3DRS_CCW_STENCILFUNC - none

D3DRS_COLORWRITEENABLE1
D3DRS_COLORWRITEENABLE2
D3DRS_COLORWRITEENABLE3 - none


D3DRS_WRAP8-D3DRS_WRAP15 - none

D3DRS_SEPARATEALPHABLENDENABLE - интересный флаг, но пока не применим.
D3DRS_SRCBLENDALPHA - none
D3DRS_DESTBLENDALPHA - none
D3DRS_BLENDOPALPHA - none

            
///////////////О сортировке по материалам.
   У нас есть 2 типа объектов - Object3dx и Simply3dx.
   Реально они отличаются только тяжестью надстройки сверху.

   Пусть будет StaticPrimitive3dx - vertexbuffer+indexbuffer + указание где что лежит и какие ноды использует.

//////////////О сравнении расстояния
Не вычислять (pos-camerapos).norm()
Вычислять только z, и работать с ним dot(p,camera_matrix[z])+camera_matrix[z].w!

Потом есть шанс сделать сортировку по расстоянию для патиклов.
            
//////////////О демке для NVidia	
Второй рендертаржет - float32 z-буфер.



///////////////О редакторе спецэффектов.
Приделать сортировку частиц в рамках эффекта (именно в рамках эффекта а не эмиттера)
Для этого:
а - Сливать вместе текстуры одного эффекта (формализовать понятие текстурного атласа, не забыть про cTextureAviScale )
б - сбрасывать все спрайты в кучу (подумать как это сделать побыстрее, сортировать по расстоянию)
    потом их сортировать и отдавать акселератору сортированными.


г  - Слить вместе cEmitterSpl и cEmitterInt 
       Это очень полезно сделать, потому как уберет значительное дублирование кода.
       cEmitterInt - это реально тоже сплайны, только второго порядка.
       Естественно необходимо преобразование старых данных о траектории в новые.
       (сложный пункт, требует аккуратности.)
       Это необходимо для того, чтобы  в дальнейшем увеличить гибкость этого класса, за счет введения 
       новых возможностей редактирования.

д - сделать возможность задавать случайным первоначальное вращение частиц.


Очень интересный флаг D3DBLENDOP_MAX

///////////////////О метаболах
Впринципе метаболы в двухмерном случае реализуются довольно дешево.
Рисуешь кучу кружков, а потом при определённом значении получается граница.



//////////О создании и удалении графичексих объектов.
 Отделим проблему удаления графических объектов из-за интерполяции и 
 из-за многопоточности.
 Проблема удаления при многопоточности решается довольно просто - delete_list, 
 которые удаляются в графическом кванте, как только не залочен список объектов.
 
 Проблема при удалении на следующий логический квант решается удалением юнитов в конце логического кванта,
 посылая команду в графический.
 
 Здесь как раз полезно вставить хороший front-end на стороне логики.
 
   
 
//О переделке системы частиц.

1. Анимироваться объект должен в Animate
2. В Draw объект должен рисоваться по минимуму сохранённых данных.
3. Необходим минимум варантов nParticle, но при этом не должно быть лишних данных.

//О матрице для отражения и пределах.
Есть матрица отражения, нужно область для рендеринга увеличить/уменьшить. 
А видимую область оставить такой-же.
pout=Mscale*Mvp*p


//Оптимизировать под случай p0=0,p1=(0,0,1)
bool IntersectionRay(const Vect3f& a,const Vect3f& b,const Vect3f& c,
		const Vect3f& p0,const Vect3f& pn)
{
	Vect3f nab=(b-a)%pn,nbc=(c-b)%pn,nca=(a-c)%pn;
	float kab=dot(nab,(p0-a));
	float kbc=dot(nbc,(p0-b));
	float kca=dot(nca,(p0-c));
	return (kab<0 && kbc<0 && kca<0)||(kab>0 && kbc>0 && kca>0);
}

Vect3f& Vect3f::cross(const Vect3f& u, const Vect3f& v)
{
//v=0,0,1,
  x = u.y * v.z - u.z * v.y; // x=u.y
  y = u.z * v.x - u.x * v.z; // y=-u.x
  z = u.x * v.y - u.y * v.x; //
  return *this;
}

bool IntersectionRay(const Vect3f& a,const Vect3f& b,const Vect3f& c,
		const Vect3f& p0,const Vect3f& pn)
{
	Vect2f nab((b-a).y,-(b-a).x),
	       nbc((c-b).y,-(c-b).x),
	       nca((a-c).y,-(a-c).x);
	float kab=dot(nab,a);
	float kbc=dot(nbc,b);
	float kca=dot(nca,c);
	return (kab<0 && kbc<0 && kca<0)||(kab>0 && kbc>0 && kca>0);
}

bool IntersectionRaySpecial(const Vect3f& a,const Vect3f& b,const Vect3f& c)
{
	Vect2f nab((b-a).y,-(b-a).x),
	       nbc((c-b).y,-(c-b).x),
	       nca((a-c).y,-(a-c).x);
	float kab=nab.x*a.x+nab.y*a.y;
	float kbc=nbc.x*b.x+nbc.y*b.y;
	float kca=nca.x*c.x+nbc.y*c.y);
	return (kab<0 && kbc<0 && kca<0)||(kab>0 && kbc>0 && kca>0);
}

///////О динамическом bound box
Смотрим boumd box у разных частей нод.
Суммируем общий bound box.

Вопрос что выбрать - bound box или bound sphere?

bound box = трансформация 8 точек
bound sphere = сложности с оптимальным объединением сфер. 
Можно их объединять в box. А для длинных объектов использовать несколько статических сфер.

min(box.min.x,pos.x-radius) и т.д. 
Потом можно найти центр бокса и вокруг оптимально сферку нарисовать.
Для статических объектов - можно не считать.

Уточнение боунд бокса.
Сначала статический.
Если попали в область видимости - считаем динамический.
Разбиение на сферки учитывает анимационные группы.


Как разбивать на сферки? По нодам, к которым прикручена геометрия?

О delete_unused:
1) Надо сделать чтобы 3dx с разным количеством LOD мог перегружаться и из кеша.
2) Никогда не удалять 3dx из кеша.
3) Удалять только те текстуры, которые новые генерятся. Хотя может лучше вообще не удалять, для надёжности. Хотя текстур конечно много может сгенерироваться, дас.

